# Intro to formal languages. Regular grammars. Finite Automata.  

### Course: Formal Languages & Finite Automata  
### Author: Mohamed Dhiaeddine Hassine , st.gr.FAF-233
### Verified by: Dumitru Crețu, University Assistant 

----

## Theoretical Background

In computer science, formal languages enable communication between humans and machines. This lab explores key concepts like regular grammars and finite automata, focusing on their implementation in Python.

A formal language includes:

* **Alphabet:** Valid characters
* **Vocabulary:** Valid words
* **Grammar:** Rules defining the language


### Formal Languages

A formal language is a set of strings built from symbols based on specific rules (grammar). It's used in computer science, linguistics, and mathematics to define structured systems.

Formally, a language over an alphabet Σ is a subset of Σ\*, the set of all possible strings from Σ. For example, if Σ = {0, 1}, then Σ\* includes ε (empty string), 0, 1, 00, 01, etc.


### Formal Grammars

A formal grammar is a set of production rules that describe how to form valid strings in a language. Formally, a grammar G is defined as a quadruple (N, T, P, S), where:
- N is a set of non-terminal symbols
- T is a set of terminal symbols
- P is a set of production rules
- S is the start symbol (S ∈ N)

The production rules in P have the form α → β, where α and β are strings of symbols from (N ∪ T), and α contains at least one symbol from N.

#### Chomsky Hierarchy

Noam Chomsky introduced a hierarchy of grammars, categorizing them into four types:

1. **Type 0 (Unrestricted)**: No restrictions on production rules. These grammars generate recursively enumerable languages.
2. **Type 1 (Context-sensitive)**: Production rules of the form αAβ → αγβ, where A is a non-terminal and γ is a non-empty string.
3. **Type 2 (Context-free)**: Production rules of the form A → γ, where A is a non-terminal.
4. **Type 3 (Regular)**: Production rules of the form A → a or A → aB, where A and B are non-terminals and a is a terminal.
5. 
Regular grammars, also known as Type 3 grammars, are the simplest class in the Chomsky hierarchy. They can be directly modeled using finite automata.


### Regular Grammars

Regular grammars are a type of formal grammar used to generate regular languages. They exist in two forms:

1. **Right Regular Grammar**: Rules like A → a or A → aB
2. **Left Regular Grammar**: Rules like A → a or A → Ba

These grammars are notable because they can be easily converted to and from finite automata.


### Finite Automata

A finite automaton (FA) is a simple computational model with limited memory. It processes input symbols sequentially, updating its state based on predefined rules.

An FA is defined as a 5-tuple (Q, Σ, δ, q₀, F), where:

* **Q**: Set of states
* **Σ**: Input alphabet
* **δ**: Transition function (Q × Σ → Q for DFA, Q × Σ → P(Q) for NFA)
* **q₀**: Initial state
* **F**: Accepting states


#### Types of Finite Automata
1. **Deterministic Finite Automaton (DFA)**: Each state has exactly one transition for every input symbol.
2. **Non-deterministic Finite Automaton (NFA)**: States can have multiple transitions for the same input or ε-transitions (without input).

Despite their differences, both DFA and NFA recognize the same class of languages: regular languages.


### Equivalence of Regular Grammars and Finite Automata

There is a fundamental equivalence between regular grammars and finite automata:

1. Any language generated by a regular grammar can be recognized by a finite automaton.
2. Any language recognized by a finite automaton can be generated by a regular grammar.

This equivalence is the foundation for many algorithms in compiler design, text processing, and pattern matching.

## Objectives

This laboratory work aims to achieve the following objectives:

1. Understand the concept of formal languages and their requirements
2. Set up a project environment for ongoing work throughout the semester
3. Implement a `Grammar` class capable of:
   - Generating valid strings from a defined grammar
   - Converting itself to a Finite Automaton
4. Implement a `FiniteAutomaton` class with string validation capabilities

## Implementation description

The Grammar class provides a lightweight framework for handling regular grammars, specifically right-regular grammars, and generating strings derived from them. It does not use a strict formal structure like (N, T, P, S) but infers these components from a formatted grammar string.



Internal Representation:

    'parsed_grammar': A dictionary mapping non-terminals to a list of productions in the form (terminal, next_non_terminal)

    'start_symbol': Symbol to begin derivations from

    'end_symbols': Optional list of accepting symbols (not actively used)




```python

class Grammar:
    def __init__(self, grammar_str):
        self.parsed_grammar = self.parseGrammar(grammar_str)
        self.start_symbol = None
        self.end_symbols = []

    def setStartSymbol(self, start_symbol):
        self.start_symbol = start_symbol

    def addEndSymbols(self, end_symbol):
        if isinstance(end_symbol, list):
            self.end_symbols.extend(end_symbol)
        else:
            self.end_symbols.append(end_symbol)

    def parseGrammar(self, grammar_str):
        productions = defaultdict(list)
        for line in grammar_str.strip().splitlines():
            if line.strip() and '→' in line:
                non_terminal, productions_str = line.split('→')
                nt = non_terminal.strip()
                prod_list = [p.strip() for p in productions_str.split('|')]

                for prod in prod_list:
                    prod = prod.replace(" ", "")
                    if len(prod) == 1:
                        productions[nt].append((prod, None))
                    elif len(prod) == 2:
                        productions[nt].append((prod[0], prod[1]))
                    else:
                        productions[nt].append((prod[0], prod[1:]))
        return productions

    def printGrammarSet(self):
        for non_terminal, productions in self.parsed_grammar.items():
            print(f"{non_terminal}: {productions}")

    def getStrings(self, max_count=10, max_depth=10):
        result_strs = set()

        def rec(nt, current, depth):
            if depth > max_depth or len(result_strs) >= max_count:
                return

            for prod in self.parsed_grammar.get(nt, []):
                terminal, next_nt = prod
                new_str = current + terminal

                if next_nt is None:
                    result_strs.add(new_str)
                    if len(result_strs) >= max_count:
                        return
                else:
                    rec(next_nt, new_str, depth + 1)

        if self.start_symbol:
            rec(self.start_symbol, "", 0)
        return list(result_strs)


```

#### Method Analysis: `parseGrammar(grammar_str)`

Function: Parses grammar rules from a formatted string into a dictionary structure.

Process:

    Splits each production line into LHS (non-terminal) and RHS (productions).

    Breaks RHS into individual productions using '|'.

    Cleans spaces and creates production tuples:

        (a, None) for terminal-only

        (a, B) for terminal followed by non-terminal

#### Method Analysis: `getStrings(max_count=10, max_depth=10)`
Purpose: Recursively generates up to max_count strings from the grammar using a depth-limited approach.

Algorithm:

    Start from start_symbol

    Recursively expand using right-regular rules

    Stop when a terminal-only production is hit (next_nt = None)

    Prune based on depth or result count

Key Features:

    Prevents infinite loops using max_depth

    Efficient string generation for demo/testing



### Finite Automaton Implementation

The FiniteAutomaton class models a non-deterministic finite automaton (NFA) derived from a regular grammar. It uses standard automata components (states, transitions, start/final states) and offers simulation capabilities for string recognition

Input: A Grammar object that includes:

    non_terminals: The grammar's state symbols

    terminals: The input alphabet

    productions: Production rules used to build transitions

    start_symbols: The starting state

Internal Representation:

    states: Set of all states = non-terminals + special final state F

    alphabet: Set of valid input symbols

    transitions: Dictionary {state: {symbol: [next_states]}}

    start_state: Starting state of the automaton

    final_states: Set containing the accepting state "F"



```python
class FiniteAutomata:
    def __init__(self, grammar_str):
        self.parsed_grammar = self.parseGrammar(grammar_str)
        self.start_symbol = None
        self.end_symbols = []

    def setStartSymbol(self, start_symbol):
        self.start_symbol = start_symbol

    def addEndSymbols(self, end_symbol):
        if isinstance(end_symbol, list):
            self.end_symbols.extend(end_symbol)
        else:
            self.end_symbols.append(end_symbol)

    def parseGrammar(self, grammar_str):
        productions = defaultdict(list)
        for line in grammar_str.strip().splitlines():
            if line.strip() and '→' in line:
                non_terminal, productions_str = line.split('→')
                nt = non_terminal.strip()
                prod_list = [p.strip() for p in productions_str.split('|')]

                for prod in prod_list:
                    prod = prod.replace(" ", "")
                    if len(prod) == 1:
                        productions[nt].append((prod, None))
                    elif len(prod) == 2:
                        productions[nt].append((prod[0], prod[1]))
                    else:
                        productions[nt].append((prod[0], prod[1:]))
        return productions

    def checkStr(self, check_str):
        def rec(nt, i):
            if i == len(check_str):
                return self._canDeriveEpsilon(nt)

            for prod in self.parsed_grammar.get(nt, []):
                terminal, next_nt = prod

                if i < len(check_str) and check_str[i] == terminal:
                    if next_nt is None:
                        if i + 1 == len(check_str):
                            return True
                    else:
                        if rec(next_nt, i + 1):
                            return True
            return False

        if not self.start_symbol:
            return False
        return rec(self.start_symbol, 0)

    def _canDeriveEpsilon(self, nt):
        return False

```




## Testing

### Grammar Tests

The TestFormalLanguage class is a unit test suite using Python’s unittest framework. It validates the behavior of two key components:

    Grammar: for string generation based on formal grammar

    FiniteAutomata: for simulating a finite automaton that recognizes those strings

```python

```


#### Test Analysis: Grammar Tests

The `TestGrammar` class contains four test cases that verify different aspects of the `Grammar` class's functionality:

1. `test_generate_string_contains_only_terminals`: Ensures that generated strings contain only terminal symbols, which is a fundamental requirement for string generation from a grammar.
2. `test_generate_multiple_strings`: Verifies that the `generate_strings` method correctly generates the requested number of strings.
3. `test_generated_strings_are_not_empty`: Checks that generated strings are not empty, which could happen if the grammar contained problematic production rules.
4. `test_productions_are_followed`: Another check that all characters in the generated string are terminals, ensuring that the production rules are correctly followed.

These tests provide good coverage of the basic functionality of the `Grammar` class, ensuring that it generates valid strings according to the defined grammar.

#### Test Analysis: Finite Automaton Tests

The `TestFiniteAutomaton` class contains three test cases that verify the string validation functionality of the `FiniteAutomaton` class:

1. `test_check_valid_string`: Ensures that a known valid string is correctly accepted by the automaton.
2. `test_check_invalid_string`: Verifies that a known invalid string is correctly rejected by the automaton.
3. `test_empty_string`: Checks that an empty string is rejected by the automaton, which is correct for this particular grammar.

These tests provide basic validation of the `FiniteAutomaton` class's functionality, ensuring that it correctly distinguishes between valid and invalid strings.

## Results and Analysis
Parsed Grammar:
S: [('a', 'B'), ('c', None)]
B: [('a', 'D'), ('b', 'B'), ('c', 'C')]
D: [('a', 'D'), ('b', 'S'), ('c', None)]
C: [('c', None)]

Generated strings (first 18):
  aaaaaaaaaac
  aaaaaaaaabc
  aaaaaaaaac
  aaaaaaaabc
  aaaaaaaac
  aaaaaaabaac
  aaaaaaabacc
  aaaaaaabc
  aaaaaaac
  aaaaaabaaac
  aaaaaabaac
  aaaaaabc
  aaaaaac
  aaaaac
  aaaac
  aaac
  aac
  c

Testing strings with automaton:
  'c': Accepted!
  'ac': Rejected!
  'aac': Accepted!
  'abc': Rejected!
  'cccc': Rejected!
  'abcc': Accepted!

## Conclusions

This laboratory work successfully implemented and tested a formal grammar and its corresponding finite automaton. The key achievements include:

1. Creating a `Grammar` class capable of generating valid strings according to defined production rules
2. Implementing a `FiniteAutomaton` class that can validate strings against the grammar
3. Converting a grammar to a finite automaton through a well-defined algorithm
4. Testing the functionality of both classes through comprehensive unit tests

The implementation demonstrates the fundamental relationship between formal grammars and finite automata, providing a solid foundation for further exploration of more complex formal language concepts in future laboratory works.




