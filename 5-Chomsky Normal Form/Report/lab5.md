# Laboratory Work Report: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Mohamed Dhiaeddine Hassine , st.gr.FAF-233
### Verified by: Dumitru Crețu, University Assistant
----

## Theory
Chomsky Normal Form (CNF) is a simplified form of context-free grammars where all production rules follow specific patterns. It's named after Noam Chomsky, who introduced the concept in formal language theory. A grammar is in Chomsky Normal Form if every production rule is in one of these forms:

1. A → BC (where A, B, and C are non-terminal symbols)
2. A → a (where A is a non-terminal symbol and a is a terminal symbol)
3. S → ε (where S is the start symbol and ε represents the empty string)

The third rule is only allowed if the start symbol S doesn't appear on the right side of any production.

Transforming a grammar into CNF simplifies many algorithms in formal language theory, particularly the CYK (Cocke-Younger-Kasami) algorithm for parsing context-free languages.

## Objectives:
1. Understand the concept of Chomsky Normal Form and its significance in formal language theory
2. Learn the process of transforming a context-free grammar into CNF
3. Implement a method for normalizing an input grammar by the rules of CNF
4. Test the implementation with various grammars

## Implementation Description

### Conversion to Chomsky Normal Form
The conversion process involves several steps:

1. Create a new start symbol if necessary (if the original start symbol appears on the right side of any production)
2. Eliminate empty productions (ε-productions)
3. Eliminate unit productions (A → B where B is a non-terminal)
4. Eliminate inaccessible symbols (symbols that cannot be reached from the start symbol)
5. Eliminate non-productive symbols (symbols that cannot derive any terminal string)
6. Convert long productions to binary form (A → X₁X₂...Xₙ to a set of binary productions)
7. Convert terminal productions in long rules (ensure terminals only appear in productions of form A → a)

### Creating a New Start Symbol
This method first checks if the original start symbol appears on the right-hand side of any production rule. If it does, a new start symbol (typically the original symbol with an apostrophe) is created to maintain CNF requirements. This is an important first step because in CNF, if we allow S → ε, then S cannot appear on the right side of any production. Creating a new start symbol S' with the rule S' → S ensures this constraint is satisfied while preserving the language generated by the grammar.

### Eliminating Empty Productions
This step removes all ε-productions (rules that produce the empty string) except potentially one for the start symbol. The algorithm first identifies all "nullable" non-terminals—those that can derive the empty string either directly or indirectly. Then, for each production containing nullable symbols, it creates new productions that account for those symbols potentially being empty. This is done by generating all possible combinations where nullable symbols are either kept or removed. For example, if A → BCD and B and D are nullable, we add productions A → BCD, A → BC, A → CD, and A → C. This preserves the language while eliminating direct ε-productions.
```python
   def eliminate_empty_productions(self):
        print("\nStep 1: Eliminating epsilon productions")
        
        N_lambda = set()
        
        for nt, prods in self.productions.items():
            if "ε" in prods or "epsilon" in prods:
                N_lambda.add(nt)
        
        changed = True
        while changed:
            changed = False
            for nt, prods in self.productions.items():
                if nt in N_lambda:
                    continue
                
                for prod in prods:
                    if all(symbol in N_lambda for symbol in prod):
                        N_lambda.add(nt)
                        changed = True
                        break
        
        self.N_lambda = N_lambda
        print(f"Nullable non-terminals: {N_lambda}")
        
        new_productions = {nt: [] for nt in self.productions}
        
        for nt, prods in self.productions.items():
            for prod in prods:
                if prod == "ε" or prod == "epsilon":
                    continue
                
                nullable_positions = []
                for i, symbol in enumerate(prod):
                    if symbol in N_lambda:
                        nullable_positions.append(i)
                
                all_subsets = chain.from_iterable(
                    combinations(nullable_positions, r) 
                    for r in range(len(nullable_positions) + 1)
                )
                
                for subset in all_subsets:
                    new_prod = "".join(symbol for i, symbol in enumerate(prod) if i not in subset)
                    
                    if new_prod and new_prod not in new_productions[nt]:
                        new_productions[nt].append(new_prod)
        
        self.productions = new_productions
        
        self.productions = {nt: prods for nt, prods in self.productions.items() if prods}
        
        self.print_grammar("Grammar after eliminating epsilon productions:")
        return self
```
### Eliminating Unit Productions
This method eliminates unit productions (A → B where B is a non-terminal) by computing the transitive closure of unit derivations and replacing them with direct derivations. The algorithm first finds all pairs (A, B) such that A can derive B through a sequence of unit productions (this is called a "unit pair"). Then, for each such pair, it replaces the unit production A → B with all the non-unit productions of B. This preserves the language while ensuring no unit productions remain in the grammar. This step is essential because CNF only allows productions with exactly two non-terminals or a single terminal on the right side.
```python
   def eliminate_unit_productions(self):
        print("\nStep 2: Eliminating unit productions (renaming)")
        
        unit_pairs = {nt: {nt} for nt in self.non_terminals}
        
        changed = True
        while changed:
            changed = False
            for A in self.non_terminals:
                for prod in self.productions.get(A, []):
                    if prod in self.non_terminals:
                        B = prod
                        for C in unit_pairs.get(B, set()):
                            if C not in unit_pairs[A]:
                                unit_pairs[A].add(C)
                                changed = True
        
        print("Unit pairs:", unit_pairs)
        
        new_productions = {nt: [] for nt in self.non_terminals}
        
        for A in self.non_terminals:
            for B in unit_pairs[A]:
                for prod in self.productions.get(B, []):
                    if prod not in self.non_terminals and prod not in new_productions[A]:
                        new_productions[A].append(prod)
        
        self.productions = new_productions
        
        self.productions = {nt: prods for nt, prods in self.productions.items() if prods}
        
        self.print_grammar("Grammar after eliminating unit productions:")
        return self

```
### Eliminating Inaccessible Symbols
This step removes all symbols that cannot be reached from the start symbol. Using a breadth-first search (BFS) algorithm, it identifies all "accessible" symbols—those that can be derived from the start symbol through a sequence of production rules. Any non-terminal that isn't accessible is removed from the grammar along with its productions. This step simplifies the grammar without changing the language it generates, since inaccessible symbols by definition cannot contribute to any string in the language.
```python
  def eliminate_inaccessible_symbols(self):
        print("\nStep 3: Eliminating inaccessible symbols")
        
        accessible = {self.start_symbol}
        queue = [self.start_symbol]
        
        while queue:
            current = queue.pop(0)
            for prod in self.productions.get(current, []):
                for symbol in prod:
                    if symbol in self.non_terminals and symbol not in accessible:
                        accessible.add(symbol)
                        queue.append(symbol)
        
        print(f"Accessible non-terminals: {accessible}")
        
        inaccessible = self.non_terminals - accessible
        print(f"Inaccessible non-terminals being removed: {inaccessible}")
        
        self.non_terminals = accessible
        self.productions = {nt: prods for nt, prods in self.productions.items() if nt in accessible}
        
        self.print_grammar("Grammar after eliminating inaccessible symbols:")
        return self

    def eliminate_non_productive_symbols(self):
        print("\nStep 4: Eliminating non-productive symbols")
        
        productive = set()
        
        for nt, prods in self.productions.items():
            for prod in prods:
                if all(symbol in self.terminals for symbol in prod):
                    productive.add(nt)
                    break
        
        changed = True
        while changed:
            changed = False
            for nt, prods in self.productions.items():
                if nt in productive:
                    continue
                
                for prod in prods:
                    if all(symbol in self.terminals or symbol in productive for symbol in prod):
                        productive.add(nt)
                        changed = True
                        break
        
        print(f"Productive non-terminals: {productive}")
        
        non_productive = self.non_terminals - productive
        print(f"Non-productive non-terminals being removed: {non_productive}")
        
        self.non_terminals = productive
        
        new_productions = {}
        for nt in productive:
            new_productions[nt] = []
            for prod in self.productions.get(nt, []):
                if all(symbol not in self.non_terminals or symbol in productive for symbol in prod):
                    new_productions[nt].append(prod)
        
        self.productions = new_productions
        
        self.productions = {nt: prods for nt, prods in self.productions.items() if prods}
        
        self.print_grammar("Grammar after eliminating non-productive symbols:")
        return self
```
### Converting terminal productions

```python
 def convert_terminal_mixed_productions(self):
        print("\nConverting terminal-mixed productions")
        
        new_productions = {}
        new_non_terminals = set(self.non_terminals)
        terminal_non_terminals = {}
        
        for terminal in self.terminals:
            new_nt = f"T_{terminal}"
            terminal_non_terminals[terminal] = new_nt
            new_non_terminals.add(new_nt)
            new_productions[new_nt] = [terminal]
        
        for nt, prods in self.productions.items():
            new_productions[nt] = new_productions.get(nt, [])
            
            for prod in prods:
                if len(prod) == 1:
                    new_productions[nt].append(prod)
                else:
                    new_prod = ""
                    for symbol in prod:
                        if symbol in self.terminals:
                            new_prod += terminal_non_terminals[symbol]
                        else:
                            new_prod += symbol
                    new_productions[nt].append(new_prod)
        
        self.non_terminals = new_non_terminals
        self.productions = new_productions
        
        self.print_grammar("Grammar after converting terminal-mixed productions:")
        return self
```
### Complete Conversion Process
The complete conversion process is orchestrated by the convert_to_chomsky_form method, which calls each of the above methods in sequence:
```python
 def convert_to_chomsky_normal_form(self):
        print("\nConverting grammar to Chomsky Normal Form")
        
        self.eliminate_empty_productions()
        self.eliminate_unit_productions()
        self.eliminate_inaccessible_symbols()
        self.eliminate_non_productive_symbols()
        self.convert_to_binary_form()
        self.convert_terminal_mixed_productions()
        
        print("\nConversion to Chomsky Normal Form complete!")
        return self
```
### Results
Initial grammar for Variant 13:
Non-terminals: {'D', 'S', 'A', 'B', 'C'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  S -> aB | DA
  A -> a | BD | bDAB
  B -> b | BA
  D -> ε | BA
  C -> BA


Converting grammar to Chomsky Normal Form

Step 1: Eliminating epsilon productions
Nullable non-terminals: {'D'}

Grammar after eliminating epsilon productions:
Non-terminals: {'D', 'S', 'A', 'B', 'C'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  S -> aB | DA | A
  A -> a | BD | B | bDAB | bAB
  B -> b | BA
  D -> BA
  C -> BA


Step 2: Eliminating unit productions (renaming)
Unit pairs: {'D': {'D'}, 'S': {'A', 'B', 'S'}, 'A': {'A', 'B'}, 'B': {'B'}, 'C': {'C'}}

Grammar after eliminating unit productions:
Non-terminals: {'D', 'S', 'A', 'B', 'C'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  D -> BA
  S -> a | BD | bDAB | bAB | b | BA | aB | DA
  A -> a | BD | bDAB | bAB | b | BA
  B -> b | BA
  C -> BA


Step 3: Eliminating inaccessible symbols
Accessible non-terminals: {'A', 'B', 'D', 'S'}
Inaccessible non-terminals being removed: {'C'}

Grammar after eliminating inaccessible symbols:
Non-terminals: {'A', 'B', 'D', 'S'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  D -> BA
  S -> a | BD | bDAB | bAB | b | BA | aB | DA
  A -> a | BD | bDAB | bAB | b | BA
  B -> b | BA


Step 4: Eliminating non-productive symbols
Productive non-terminals: {'A', 'B', 'D', 'S'}
Non-productive non-terminals being removed: set()

Grammar after eliminating non-productive symbols:
Non-terminals: {'A', 'B', 'D', 'S'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  A -> a | BD | bDAB | bAB | b | BA
  B -> b | BA
  D -> BA
  S -> a | BD | bDAB | bAB | b | BA | aB | DA


Converting productions to binary form

Grammar after converting to binary form:
Non-terminals: {'X4', 'A', 'B', 'X1', 'X5', 'X2', 'X3', 'D', 'S', 'X6'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  A -> a | BD | bX1 | bX3 | b | BA
  X1 -> DX2
  X2 -> AB
  X3 -> AB
  B -> b | BA
  D -> BA
  S -> a | BD | bX4 | bX6 | b | BA | aB | DA
  X4 -> DX5
  X5 -> AB
  X6 -> AB


Converting terminal-mixed productions

Grammar after converting terminal-mixed productions:
Non-terminals: {'T_b', 'X4', 'A', 'B', 'X1', 'X5', 'X2', 'X3', 'D', 'S', 'X6', 'T_a'}
Terminals: {'b', 'a'}
Start symbol: S
Productions:
  T_b -> b
  T_a -> a
  A -> a | BD | T_bX1 | T_bX3 | b | BA
  X1 -> DX2
  X2 -> AB
  X3 -> AB
  B -> b | BA
  D -> BA
  S -> a | BD | T_bX4 | T_bX6 | b | BA | T_aB | DA
  X4 -> DX5
  X5 -> AB
  X6 -> AB


Conversion to Chomsky Normal Form complete!
## Conclusion
This lab explored Chomsky Normal Form (CNF) and its role in formal language theory. We implemented a step-by-step conversion of context-free grammars into CNF, handling ε-productions, unit rules, and long or terminal-inclusive productions.

The approach was tested on complex grammars, proving both accurate and robust. This exercise strengthened understanding of grammar transformations and practical algorithm design for language processing tasks.